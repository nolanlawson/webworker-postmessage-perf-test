<html>
<body>
  <h1>Web Worker perf test</h1>
  <p>Look in the console</p>
  <pre id="display"></pre>
  <script src="https://rawgit.com/nicjansma/usertiming.js/master/dist/usertiming.min.js"></script>
  <script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js"></script>
  <script>

    var MAX_MESSAGE_SIZE = 30;
    var ITERATIONS = 50000;

    var workers = {
      arraybuffer: new Worker('arraybuffer.js'),
      'single-arraybuffer': new Worker('single-arraybuffer.js'),
      msgpack: new Worker('msgpack.js'),
      full: new Worker('full.js'),
      partial: new Worker('partial.js'),
      none: new Worker('none.js')
    };

    var cStyleBuffer = new ArrayBuffer(MAX_MESSAGE_SIZE * 1000);

    function cStyleBufferToBinaryString(buffer) {
      var binary = "";
      var bytes = new Uint8Array(buffer);
      var length = bytes.byteLength;

      var i = 0;
      while (bytes[i] > 0) {
        binary += String.fromCharCode(bytes[i]);
        i++;
      }
      return binary;
    }

    function binaryStringToCStyleBuffer(bin, buf) {
      var length = bin.length;
      var arr = new Uint8Array(buf);
      for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
      }
      arr[i] = 0;

      return buf;
    }

    function arrayBufferToBinaryString(buffer) {
      var binary = "";
      var bytes = new Uint8Array(buffer);
      var length = bytes.byteLength;
      for (var i = 0; i < length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return binary;
    }

    function binaryStringToArrayBuffer(bin) {
      var length = bin.length;
      var buf = new ArrayBuffer(length);
      var arr = new Uint8Array(buf);
      for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
      }
      return buf;
    }

    function createObject(iterations) {
      var obj = {};
      for (var i = 0; i < iterations; i++) {
        obj[Math.random().toString()] = Math.random().toString();
      }
      return obj;
    }

    function test(iterations, stringification, log, cb) {
      var obj = createObject(iterations);
      var worker = workers[stringification];

      var i = 0;

      function listener(e) {
        var message;
        if (stringification === 'full') {
          message = JSON.parse(e.data);
        } else if (stringification === 'partial') {
          message = JSON.parse(e.data.msg);
        } else if (stringification === 'arraybuffer') {
          message = JSON.parse(arrayBufferToBinaryString(e.data));
        } else if (stringification === 'single-arraybuffer') {
          message = JSON.parse(cStyleBufferToBinaryString(e.data));
          cStyleBuffer = e.data;
        } else if (stringification === 'msgpack') {
          message = msgpack.decode(new Uint8Array(e.data));
        } else {
          message = e.data;
        }
        next();
      }

      function next() {
        if (++i <= ITERATIONS) {
          var message;
          if (stringification === 'full') {
            message = JSON.stringify(obj);
            worker.postMessage(message);
          } else if (stringification === 'partial') {
            message = {msg: JSON.stringify(obj)};
            worker.postMessage(message);
          } else if (stringification === 'arraybuffer') {
            message = binaryStringToArrayBuffer(JSON.stringify(obj));
            worker.postMessage(message, [message]);
          } else if (stringification === 'single-arraybuffer') {
            message =
              binaryStringToCStyleBuffer(JSON.stringify(obj), cStyleBuffer);
            worker.postMessage(message, [message]);
          } else if (stringification === 'msgpack') {
            message = msgpack.encode(obj).buffer;
            worker.postMessage(message, [message]);
          } else {
            message = obj;
            worker.postMessage(message);
          }
        } else {
          if (log) {
            performance.measure(
              stringification + '-size-' + iterations,
              stringification + '-size-' + iterations + '-start');
            console.log(
              'size:',
              iterations,
              performance.getEntriesByName(
                stringification + '-size-' + iterations
              ).pop().duration
            );
          }
          worker.removeEventListener('message', listener);
          cb();
        }
      }

      worker.addEventListener('message', listener);
      if (log) {
        performance.mark(stringification + '-size-' + iterations + '-start');
      }
      next();
    }


    var promise = Promise.resolve();

    Object.keys(workers).forEach(function (stringification) {
      promise = promise.then(function () {
        return new Promise(function (resolve) {
          var i = -1;

          function next() {
            if (++i <= MAX_MESSAGE_SIZE) {
              test(i, stringification, true, next);
            } else {
              resolve();
            }
          }

          console.log('Testing with stringification:', stringification, '...');

          // throwaway test to warm up worker
          test(0, stringification, false, next);
        });
      });
    });

    promise = promise.then(function () {
      document.getElementById('display').innerHTML = 'Done.';
      console.log(
        Object.keys(workers).map(function (key) {
          var results = performance.getEntriesByType('measure')
            .filter(function (measure) {
              return measure.name.indexOf(key) === 0;
            })
            .map(function (measure) {
              return measure.duration;
            });
          results.unshift(key);
          console.log(results);
          return results.join(',');
        })
        .join('\n')
      );
    });

  </script>
</body>
</html>
